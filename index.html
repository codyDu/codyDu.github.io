<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="一个非常nice的iOS开发 😄">
<meta property="og:type" content="website">
<meta property="og:title" content="杜鹏飞的博客">
<meta property="og:url" content="http://dupengfei.com/index.html">
<meta property="og:site_name" content="杜鹏飞的博客">
<meta property="og:description" content="一个非常nice的iOS开发 😄">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="杜鹏飞的博客">
<meta name="twitter:description" content="一个非常nice的iOS开发 😄">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://dupengfei.com/"/>





  <title> 杜鹏飞的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b627bfa0d9d39ca04a7102b636415274";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">杜鹏飞的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录一些，分享一些，欢迎交流 😁</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://dupengfei.com/2016/12/20/我的读书清单/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="杜鹏飞">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杜鹏飞的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/20/我的读书清单/" itemprop="url">
                  我的读书清单
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-20T18:19:40+08:00">
                2016-12-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/20/我的读书清单/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/20/我的读书清单/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>好快，又是一年年末了。2016马上就要结束了。有必要整理一下书单，为下一年做准备，加油！</p>
<h2 id="已读清单"><a href="#已读清单" class="headerlink" title="已读清单"></a>已读清单</h2><font size="3"> 

<p>《Effective Objective-C 2.0：编写高质量iOS与OS X代码的52个有效方法》</p>
<p>《iOS Programming》</p>
<p>《Objective-C高级编程 iOS与OS X多线程和内存管理》</p>
<p>《The Swift Programming Language》</p>
<p>《swifter》</p>
<p>《iOS 7 Programming Pushing the Limits》</p>
<p>《图解HTTP》</p>
<p>《iOS 7 By Tutorials》</p>
<p>《iOS 8 By Tutorials》</p>
<p>《iOS UICollectionView: The Complete Guide》</p>
<p>《iOS开发进阶》by 唐巧</p>
<p><font></font></p>
<h2 id="在读清单"><a href="#在读清单" class="headerlink" title="在读清单"></a>在读清单</h2><p><font size="3"><br>《iOS 9 By Tutorials》</font></p>
<p>《iOS 10 By Tutorials》</p>
<p>《图解TCP/IP》</p>
<font>

<h2 id="未读清单"><a href="#未读清单" class="headerlink" title="未读清单"></a>未读清单</h2><p><font size="3"><br>《函数式Swift》</font></p>
<p>《Advanced Swift》</p>
<p>《iOS CORE ANIMATION》</p>
<p>《A Guide To iOS Animation》</p>
<p>《Core Data》by 喵神</p>
<p>《编程珠玑》</p>
<font>

</font></font></font>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://dupengfei.com/2016/06/20/性能优化小结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="杜鹏飞">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杜鹏飞的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/20/性能优化小结/" itemprop="url">
                  性能优化小结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-06-20T16:14:40+08:00">
                2016-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/06/20/性能优化小结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/20/性能优化小结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>用ARC管理内存 ARC(Automatic Reference Counting, 自动引用计数)和iOS5一起发布，它避免了最常见的也就是经常是由于我们忘记释放内存所造成的内存泄露。它自动为你管理retain和release的过程，所以你就不必去手动干预了。 除了帮你避免内存泄露，ARC还可以帮你提高性能，它能保证释放掉不再需要的对象的内存<em>   在正确的地方使用reuseIdentifier 这个方法把那些已经存在的cell从队列中排除，或者在必要时使用先前注册的nib或者class创造新的cell。如果没有可重用的cell，你也没有注册一个class或者nib的话，这个方法返回nil。</em>   尽可能使Views不透明 如果你有不透明的Views，你应该设置它们的opaque属性为YES。 (opaque)这个属性给渲染系统提供了一个如何处理这个view的提示。如果设为YES， 渲染系统就认为这个view是完全不透明的，这使得渲染系统优化一些渲染过程和提高性能。如果设置为NO，渲染系统正常地和其它内容组成这个View。默认值是YES。</li>
</ul>
<p>在相对比较静止的画面中，设置这个属性不会有太大影响。然而当这个view嵌在scroll view里边，或者是一个复杂动画的一部分，不设置这个属性的话会在很大程度上影响app的性能。</p>
<p>你可以在模拟器中用Debug\Color Blended Layers选项来发现哪些view没有被设置为opaque。目标就是，能设为opaque的就全设为opaque!</p>
<ol>
<li><p>避免庞大的XIB（一次性加载）</p>
<p>如果你不得不XIB的话，使他们尽量简单。尝试为每个Controller配置一个单独的XIB，尽可能把一个View Controller的view层次结构分散到单独的XIB中去。 原因是这会使系统用一个最优的方式渲染这些views。这个简单的属性在IB或者代码里都可以设定。</p>
<p>需要注意的是，当你加载一个XIB的时候所有内容都被放在了内存里，包括任何图片。如果有一个不会即刻用到的view，你这就是在浪费宝贵的内存资源了。Storyboards就是另一码事儿了，storyboard仅在需要时实例化一个view controller.</p>
<p>当家在XIB是，所有图片都被chache，如果你在做OS X开发的话，声音文件也是。Apple在相关文档中的记述是： 当你加载一个引用了图片或者声音资源的nib时，nib加载代码会把图片和声音文件写进内存。在OS X中，图片和声音资源被缓存在named cache中以便将来用到时获取。在iOS中，仅图片资源会被存进named caches。取决于你所在的平台，使用NSImage 或UIImage 的<code>imageNamed:</code>方法来获取图片资源。</p>
</li>
<li><p>不要block主线程（主：UI） 永远不要使主线程承担过多。因为UIKit在主线程上做所有工作，渲染，管理触摸反应，回应输入等都需要在它上面完成 大部分阻碍主进程的情形是你的app在做一些牵涉到读写外部资源的I/O操作，比如存储或者网络。</p>
</li>
</ol>
<p>你可以使用<code>NSURLConnection</code>异步地做网络操作: 或者使用像 AFNetworking这样的框架来异步地做这些操作。</p>
<p>如果你需要做其它类型的需要耗费巨大资源的操作(比如时间敏感的计算或者存储读写)那就用 Grand Central Dispatch，或者 NSOperation 和 NSOperationQueues.</p>
<ol>
<li><p>在Image Views中调整图片大小(与控件对应) 如果要在<code>UIImageView</code>中显示一个来自bundle的图片，你应保证图片的大小和UIImageView的大小相同。在运行中缩放图片是很耗费资源的，特别是<code>UIImageView</code>嵌套在<code>UIScrollView</code>中的情况下。</p>
<p>如果图片是从远端服务加载的你不能控制图片大小，比如在下载前调整到合适大小的话，你可以在下载完成后，最好是用background thread，缩放一次，然后在UIImageView中使用缩放后的图片。</p>
</li>
<li><p>选择正确的Collection（Arrays: 有序的一组值。使用index来lookup很快，使用value lookup很慢， 插入/删除很慢。Dictionaries: 存储键值对。 用键来查找比较快。Sets: 无序的一组值。用值来查找很快，插入/删除很快。）</p>
</li>
<li>打开gzip压缩 （服务端和你的app） 好消息是，iOS已经在NSURLConnection中默认支持了gzip压缩，当然AFNetworking这些基于它的框架亦然。像Google App Engine这些云服务提供者也已经支持了压缩输出</li>
<li><p>重用和延迟加载Views 这里我们用到的技巧就是模仿<code>UITableView</code>和<code>UICollectionView</code>的操作: 不要一次创建所有的subview，而是当需要时才创建，当它们完成了使命，把他们放进一个可重用的队列中。</p>
<p>这样的话你就只需要在滚动发生时创建你的views，避免了不划算的内存分配。</p>
<p>创建views的能效问题也适用于你app的其它方面。想象一下一个用户点击一个按钮的时候需要呈现一个view的场景。有两种实现方法：</p>
<ol>
<li>创建并隐藏这个view当这个screen加载的时候，当需要时显示它；</li>
<li>当需要时才创建并展示。 每个方案都有其优缺点。</li>
</ol>
<p>用第一种方案的话因为你需要一开始就创建一个view并保持它直到不再使用，这就会更加消耗内存。然而这也会使你的app操作更敏感因为当用户点击按钮的时候它只需要改变一下这个view的可见性。</p>
<p>第二种方案则相反-消耗更少内存，但是会在点击按钮的时候比第一种稍显卡顿。</p>
</li>
<li><p>Cache, Cache, 还是Cache！（NSCache：系统回收内存的时候它会自动删掉它的内容） 你可以通过 NSURLConnection 获取一个URL request， AFNetworking也一样的。这样你就不必为采用这条tip而改变所有的networking代码了。 如果你需要缓存其它不是HTTP Request的东西，你可以用NSCache。</p>
</li>
<li><p>权衡渲染方法（CALayer， CoreGraphics，OpenGL，Metal：性能能&amp;bundle大小）</p>
</li>
<li><p>处理内存警告 在app delegate中使用<code>applicationDidReceiveMemoryWarning:</code> 的方法 在你的自定义UIViewController的子类(subclass)中覆盖<code>didReceiveMemoryWarning</code> 注册并接收 UIApplicationDidReceiveMemoryWarningNotification 的通知 一旦收到这类通知，你就需要释放任何不必要的内存使用。 UIViewController的默认行为是移除一些不可见的view， 它的一些子类则可以补充这个方法，删掉一些额外的数据结构。一个有图片缓存的app可以移除不在屏幕上显示的图片。</p>
<p>这样对内存警报的处理是很必要的，若不重视，你的app就可能被系统杀掉。</p>
<p>然而，当你一定要确认你所选择的object是可以被重现创建的来释放内存。一定要在开发中用模拟器中的内存提醒模拟去测试一下。</p>
</li>
<li><p>重用大开销的对象 还需要注意的是，其实设置一个NSDateFormatter的速度差不多是和创建新的一样慢的！所以如果你的app需要经常进行日期格式处理的话，你会从这个方法中得到不小的性能提升。</p>
</li>
<li>使用Sprite Sheets（渲染速度加快，甚至比标准的屏幕渲染方法节省内存。）</li>
<li>避免反复处理数据（从特定key中取数据，那么就使用键值对的dictionary） 你需要数据来展示一个table view,最好直接从服务器取array结构的数据以避免额外的中间数据结构改变。</li>
<li><p>选择正确的数据格式（JSON和XML） 解析JSON会比XML更快一些，JSON也通常更小更便于传输。从iOS5起有了官方内建的JSON deserialization 就更加方便使用了。</p>
<p>但是XML也有XML的好处，比如使用SAX 来解析XML就像解析本地文件一样，你不需像解析json一样等到整个文档下载完成才开始解析。当你处理很大的数据的时候就会极大地减低内存消耗和增加性能</p>
</li>
<li><p>正确地设定Background Images（colorWithPatternImage，UIImageView） 如果你使用全画幅的背景图，你就必须使用UIImageView因为UIColor的colorWithPatternImage是用来创建小的重复的图片作为背景的。这种情形下使用UIImageView可以节约不少的内存：</p>
<p>如果你用小图平铺来创建背景，你就需要用UIColor的colorWithPatternImage来做了，它会更快地渲染也不会花费很多内存：</p>
</li>
<li><p>减少使用Web特性（不像驱动Safari的那么快，尽可能移除不必要的javascript，避免使用过大的框架。能只用原生js就更好了） 另外，尽可能异步加载例如用户行为统计script这种不影响页面表达的javascript。</p>
<p>最后，永远要注意你使用的图片，保证图片的符合你使用的大小。使用Sprite sheet提高加载速度和节约内存。</p>
</li>
<li><p>设定Shadow Path（QuartzCore：Core Animation不得不先在后台得出你的图形并加好阴影然后才渲染，这开销是很大的。） 使用shadow path的话iOS就不必每次都计算如何渲染，它使用一个预先计算好的路径。但问题是自己计算path的话可能在某些View中比较困难，且每当view的frame变化的时候你都需要去update shadow path.</p>
</li>
<li><p>优化你的Table View</p>
<p>正确使用<code>reuseIdentifier</code>来重用cells 尽量使所有的view opaque，包括cell自身 避免渐变，图片缩放，后台选人 缓存行高 如果cell内现实的内容来自web，使用异步加载，缓存请求结果 使用<code>shadowPath</code>来画阴影 减少subviews的数量 尽量不适用<code>cellForRowAtIndexPath:</code>，如果你需要用到它，只用一次然后缓存结果 使用正确的数据结构来存储数据 使用<code>rowHeight</code>, <code>sectionFooterHeight</code> 和 <code>sectionHeaderHeight</code>来设定固定的高，不要请求delegate</p>
</li>
<li><p>选择正确的数据存储选项</p>
<p>使用<code>NSUerDefaults</code> 使用XML, JSON, 或者 plist 使用NSCoding存档 使用类似SQLite的本地SQL数据库 使用 Core Data NSUserDefaults的问题是什么？虽然它很nice也很便捷，但是它只适用于小数据，比如一些简单的布尔型的设置选项，再大点你就要考虑其它方式了</p>
<p>XML这种结构化档案呢？总体来说，你需要读取整个文件到内存里去解析，这样是很不经济的。使用SAX又是一个很麻烦的事情。</p>
<p>NSCoding？不幸的是，它也需要读写文件，所以也有以上问题。</p>
<p>在这种应用场景下，使用SQLite 或者 Core Data比较好。使用这些技术你用特定的查询语句就能只加载你需要的对象。</p>
<p>在性能层面来讲，SQLite和Core Data是很相似的。他们的不同在于具体使用方法。Core Data代表一个对象的graph model，但SQLite就是一个DBMS。Apple在一般情况下建议使用Core Data，但是如果你有理由不使用它，那么就去使用更加底层的SQLite吧。</p>
<p>如果你使用SQLite，你可以用FMDB(<a href="https://github.com/ccgus/fmdb" target="_blank" rel="external">https://github.com/ccgus/fmdb</a>)这个库来简化SQLite的操作，这样你就不用花很多经历了解SQLite的C API了。</p>
</li>
<li><p>加速启动时间 尽可能做更多的异步任务，比如加载远端或者数据库数据，解析数据。</p>
</li>
</ol>
<p>还是那句话，避免过于庞大的XIB，因为他们是在主线程上加载的。所以尽量使用没有这个问题的Storyboards吧！</p>
<p>注意，用Xcode debug时watchdog并不运行，一定要把设备从Xcode断开来测试启动速度</p>
<ol>
<li><p>使用Autorelease Pool</p>
<p>你创建很多临时对象，你会发现内存一直在减少直到这些对象被release的时候。这是因为只有当UIKit用光了autorelease pool的时候memory才会被释放。</p>
</li>
<li><p>选择是否缓存图片（一个是用<code>imageNamed</code>：当加载时会缓存图片，用一个指定的名字在系统缓存中查找并返回一个图片对象如果它存在的话。如果缓存中没有找到相应的图片，这个方法从指定的文档中加载然后缓存并返回这个对象，二是用<code>imageWithContentsOfFile</code>，仅加载图片）</p>
<p>如果你要加载一个大图片而且是一次性使用，那么就没必要缓存这个图片，用<code>imageWithContentsOfFile</code>足矣，这样不会浪费内存来缓存它。</p>
<p>然而，在图片反复重用的情况下<code>imageNamed</code>是一个好得多的选择。</p>
</li>
<li><p>尽量避免日期格式转换（尽量选择Unix时间戳） 许多web API会以微秒的形式返回时间戳，因为这种格式在javascript中更方便使用。记住用<code>dateFromUnixTimestamp</code>之前除以1000就好了。</p>
</li>
</ol>
<hr>
<p>tableView优化总结：</p>
<blockquote>
<p>卡顿：重用是否成功（自己写）—是否是多次请求-青花瓷（每次滚动）—github，博客，微博–Instruments三件套(Time Profiler,Core Animation,GPU Driver)—GPU-CPU-代码逻辑-1.cell高度没有缓存。2. refreshData（reloadData）2次。 3.懒加载View 4.圆角问题 5.尺寸对应 6.NSDateFormatter 7.UIImage缓存取舍 8.手动 Drawing（Cell 中 view 的组织复杂）9. UI 线程的时间 10.缓存一切可以缓存的！就是“用空间替换时间”！</p>
</blockquote>
<ol>
<li><p>最常用的就是cell的重用， 注册重用标识符</p>
<p>如果不重用cell时，每当一个cell显示到屏幕上时，就会重新创建一个新的cell 如果有很多数据的时候，就会堆积很多cell。如果重用cell，为cell创建一个ID 每当需要显示cell 的时候，都会先去缓冲池中寻找可循环利用的cell，如果没有再重新创建cell 设置正确的reuseIdentifer以重用cell</p>
</li>
<li><p>避免cell的重新布局</p>
<p>cell的布局填充等操作 比较耗时，一般创建时就布局好 如可以将cell单独放到一个自定义类，初始化时就布局好</p>
</li>
<li><p>提前计算并缓存cell的属性及内容</p>
<p>在cellForRowAtIndexPath:中尽量做更少的操作。如果需要做一些处理，那么最好做过一次之后，就将结果缓存起来。 当我们创建cell的数据源方法时，编译器并不是先创建cell 再定cell的高度 而是先根据内容一次确定每一个cell的高度，高度确定后，再创建要显示的cell，滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell</p>
</li>
<li><p>减少cell中控件的数量</p>
<p>尽量使cell得布局大致相同，不同风格的cell可以使用不用的重用标识符，初始化时添加控件， 不适用的可以先隐藏</p>
</li>
<li><p>不要使用ClearColor，无背景色，透明度也不要设置为0</p>
<p>渲染耗时比较长 尽量将view设置为不透明，包括cell本身。</p>
</li>
<li><p>使用局部更新</p>
<p>如果只是更新某组的话，使用reloadSection进行局部更新</p>
</li>
<li><p>加载网络数据，下载图片，使用异步加载，并缓存</p>
<p>如果cell显示的内容来此网络，那么确保这些内容是通过异步来获取的</p>
</li>
<li><p>少使用addView 给cell动态添加view</p>
</li>
<li><p>按需加载cell，cell滚动很快时，只加载范围内的cell</p>
<p>注意正确使用懒加载</p>
</li>
<li><p>不要实现无用的代理方法，tableView只遵守两个协议</p>
<p>非必要的代理或者数据源方法可以省略，比如numberofsention</p>
</li>
<li><p>缓存行高：</p>
<p>如果row的高度不相同，那么将其缓存下来 estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在，这两者同时存在才会出现“窜动”的bug。所以我的建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可</p>
</li>
<li><p>避免渐变，图像缩放以及离屏绘制</p>
</li>
<li><p>使用shadowPath来设置阴影。</p>
</li>
<li><p>使用适当的数据结构来保存需要的信息。不同的结构会带来不同的操作代价。</p>
</li>
<li><p>使用rowHeight, sectionFooterHeight 和 sectionHeaderHeight 来设置一个恒定 高度，而不要从delegate中获取。</p>
</li>
<li><p>使用富文本标签代价是很昂贵的</p>
</li>
</ol>
<p>费尽周折用富文本标签，代价太昂贵了。尽可能地避免使用这个。问问你自己是否真的需要这个。如果是的话，尽可能的做缓存。</p>
<p>提前计算并缓存好高度（布局），因为heightForRowAtIndexPath:是调用最频繁的方法； 异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口； 滑动时按需加载，这个在大量图片展示，网络加载的时候很管用！（SDWebImage已经实现异步加载，配合这条性能杠杠的）。 除了上面最主要的三个方面外，还有很多几乎大伙都很熟知的优化点：</p>
<ul>
<li>正确使用reuseIdentifier来重用Cells</li>
<li>尽量使所有的view opaque，包括Cell自身</li>
<li>尽量少用或不用透明图层</li>
<li>如果Cell内现实的内容来自web，使用异步加载，缓存请求结果</li>
<li>减少subviews的数量</li>
<li>在heightForRowAtIndexPath:中尽量不使用cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果</li>
<li>尽量少用addView给Cell动态添加View，可以初始化时就添加，然后通过hide来控制是否显示</li>
<li>尽量设置Cell的view为opaque，避免GPU对Cell下面的内容也进行绘制。</li>
<li>避免大量的图片缩放、颜色渐变等。</li>
<li>避免同步的从网络、文件获取数据（这个是必须的=。=）</li>
<li>用shadowPath创建阴影。</li>
<li>尽量减少subview的数量，如多用drawRect绘制元素，替代用view显示。</li>
<li>尽量显示“大小刚好合适”的图片资源。</li>
</ul>
<p>总的来说，就是：</p>
<ul>
<li>缓存一切可以缓存的！就是“用空间替换时间”！</li>
</ul>
<p>在UITableView的Delegate、DataSource方法中，减少任何不必要的操作</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://dupengfei.com/2016/01/17/总结一下多线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="杜鹏飞">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杜鹏飞的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/17/总结一下多线程/" itemprop="url">
                  总结一下多线程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-17T00:38:40+08:00">
                2016-01-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/01/17/总结一下多线程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/17/总结一下多线程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><h4 id="1-什么是进程"><a href="#1-什么是进程" class="headerlink" title="1.什么是进程"></a>1.什么是进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">进程是指在系统中正在运行的一个应用程序</div><div class="line"></div><div class="line">每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内</div><div class="line"></div><div class="line">比如同时打开QQ、Xcode，系统就会分别启动2个进程</div><div class="line"></div><div class="line">通过“活动监视器”可以查看Mac系统中所开启的进程</div></pre></td></tr></table></figure>
<h4 id="2-什么是线程"><a href="#2-什么是线程" class="headerlink" title="2.什么是线程"></a>2.什么是线程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1个进程要想执行任务，必须得有线程（每1个进程至少要有1条线程）</div><div class="line"></div><div class="line">线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行</div><div class="line"></div><div class="line">比如使用酷狗播放音乐、使用迅雷下载电影，都需要在线程中执行</div></pre></td></tr></table></figure>
<h4 id="3-线程的串行"><a href="#3-线程的串行" class="headerlink" title="3.线程的串行"></a>3.线程的串行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1个线程中任务的执行是串行的</div><div class="line"></div><div class="line">如果要在1个线程中执行多个任务，那么只能一个一个地按顺序执行这些任务</div><div class="line"></div><div class="line">也就是说，在同一时间内，1个线程只能执行1个任务</div><div class="line"></div><div class="line">比如在1个线程中下载3个文件（分别是文件A、文件B、文件C）</div></pre></td></tr></table></figure>
<h2 id="二、多线程"><a href="#二、多线程" class="headerlink" title="二、多线程"></a>二、多线程</h2><h4 id="1-什么是多线程"><a href="#1-什么是多线程" class="headerlink" title="1.什么是多线程"></a>1.什么是多线程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1个进程中可以开启多条线程，每条线程可以并行（同时）执行不同的任务</div><div class="line"></div><div class="line">进程 -&gt;车间，线程-&gt;车间工人</div><div class="line"></div><div class="line">多线程技术可以提高程序的执行效率</div><div class="line"></div><div class="line">比如同时开启3条线程分别下载3个文件（分别是文件A、文件B、文件C）</div></pre></td></tr></table></figure>
<h4 id="2-多线程的原理"><a href="#2-多线程的原理" class="headerlink" title="2.多线程的原理"></a>2.多线程的原理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">同一时间，CPU只能处理1条线程，只有1条线程在工作（执行）</div><div class="line">多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换）</div><div class="line">如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象</div><div class="line">思考：如果线程非常非常多，会发生什么情况？</div><div class="line">CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源</div><div class="line">每条线程被调度执行的频次会降低（线程的执行效率降低）</div></pre></td></tr></table></figure>
<h4 id="3-多线程的优缺点"><a href="#3-多线程的优缺点" class="headerlink" title="3.多线程的优缺点"></a>3.多线程的优缺点</h4><p>多线程的优点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">能适当提高程序的执行效率</div><div class="line"></div><div class="line">能适当提高资源利用率（CPU、内存利用率）</div></pre></td></tr></table></figure>
<p>多线程的缺点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能</div><div class="line"></div><div class="line">线程越多，CPU在调度线程上的开销就越大</div><div class="line"></div><div class="line">程序设计更加复杂：比如线程之间的通信、多线程的数据共享</div></pre></td></tr></table></figure>
<h4 id="4-多线程在iOS开发中的应用"><a href="#4-多线程在iOS开发中的应用" class="headerlink" title="4.多线程在iOS开发中的应用"></a>4.多线程在iOS开发中的应用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">主线程:一个iOS程序运行后，默认会开启1条线程，称为“主线程”或“UI线程”</div><div class="line"></div><div class="line">主线程的主要作用</div><div class="line"></div><div class="line">显示\刷新UI界面</div><div class="line"></div><div class="line">处理UI事件（比如点击事件、滚动事件、拖拽事件等）</div></pre></td></tr></table></figure>
<p>主线程的使用注意:别将比较耗时的操作放到主线程中。</p>
<p>耗时操作会卡住主线程，严重影响UI的流畅度，给用户一种“卡”的坏体验</p>
<h2 id="多线程的四中方式"><a href="#多线程的四中方式" class="headerlink" title="多线程的四中方式"></a>多线程的四中方式</h2><h4 id="1-Pthreads"><a href="#1-Pthreads" class="headerlink" title="1. Pthreads"></a>1. Pthreads</h4><h4 id="2-NSThread"><a href="#2-NSThread" class="headerlink" title="2. NSThread"></a>2. NSThread</h4><h4 id="3-GCD"><a href="#3-GCD" class="headerlink" title="3. GCD"></a>3. GCD</h4><h4 id="4-NSOperation-amp-NSOperationQueue"><a href="#4-NSOperation-amp-NSOperationQueue" class="headerlink" title="4. NSOperation &amp; NSOperationQueue"></a>4. NSOperation &amp; NSOperationQueue</h4><h2 id="多线程的全解析-看了不信你还不会？"><a href="#多线程的全解析-看了不信你还不会？" class="headerlink" title="多线程的全解析-看了不信你还不会？"></a>多线程的全解析-看了不信你还不会？</h2><p><img src="http://ofo2isr3w.bkt.clouddn.com/multithread.png" alt=""></p>
<hr>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://dupengfei.com/2015/10/18/GPUimage(三)快速搞定自定义滤镜/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="杜鹏飞">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杜鹏飞的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/10/18/GPUimage(三)快速搞定自定义滤镜/" itemprop="url">
                  GPUImage（三）快速搞定自定义滤镜
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-18T22:21:34+08:00">
                2015-10-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GPUImage/" itemprop="url" rel="index">
                    <span itemprop="name">GPUImage</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/10/18/GPUimage(三)快速搞定自定义滤镜/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/18/GPUimage(三)快速搞定自定义滤镜/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="快速搞定自定义滤镜"><a href="#快速搞定自定义滤镜" class="headerlink" title="快速搞定自定义滤镜"></a>快速搞定自定义滤镜</h2><p>GPUImage中提供了GPUImageLookupFilter这样一个滤镜。可以大大的减少滤镜的开发时间。<br>GPUImageLookupFilter通过一个颜色映射表来实现颜色转换。这种查表法的原理就是在一张表中为每种颜色纪录一个对应的映射目标的颜色。当用查表法对一张照片做颜色映射时，只需要遍历照片的每个像素点，然后在表中找到该像素颜色对应的目标颜色，最后将该像素设置为目标颜色即可。查表法实现的前提是颜色的映射与周围的颜色无关，即一种颜色无论周围的颜色为何、无论其位于照片的哪个位置，其目标颜色都应该是相同的。</p>
<p>RGB的颜色数量表示为255<em>255</em>2555 = 16777216如果要记录每种颜色的映射结果，那么需要一千六百多万条记录，这显然无法应用到实际的工程中。为了简化起见，一般每相近的 4 种颜色采用一条记录存储，这样颜色表只需要 64<em>64</em>64 = 262144 条记录。<br>下面是一张标准的基准颜色表<br><img src="http://ofo2isr3w.bkt.clouddn.com/jizhun" alt=""><br>设计师或产品经理在PS中调整好的效果可能是这样的一组Action<br><img src="http://ofo2isr3w.bkt.clouddn.com/tiaozheng" alt="">  </p>
<p>将这些调整应用到基准颜色表上就得到了一张映射表<br><img src="http://ofo2isr3w.bkt.clouddn.com/final" alt=""><br>上表将 262144 种颜色分为 8 个块，每块64*64格，每一格的颜色都不同。进行颜色映射时，首先使用数字图像处理软件对该基准颜色表应用要模拟的滤镜来生成映射表（如下图），然后对要处理的照片的每个像素，从基准颜色表中找到该像素颜色的位置，然后在映射表的相应位置就可以得到目的颜色。</p>
<p>暗角可以使用遮罩的方式（也就是使用png图片）也可以使用这个滤镜GPUImageVignetteFilter</p>
<p>下面是demo code</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"> -(UIImage *)p_ImageFilterWithFilterName:(NSString *)filterName originImage:(UIImage *)originImage&#123;</div><div class="line"> 2 </div><div class="line"> 3  GPUImagePicture *stillImageSource = [[GPUImagePicture alloc] initWithImage:originImage];</div><div class="line"> 4  GPUImagePicture *lookupImageSource = [[GPUImagePicture alloc] initWithImage:[UIImage imageNamed:filterName]];</div><div class="line"> 5  GPUImageLookupFilter *lookupFilter = [[GPUImageLookupFilter alloc] init];</div><div class="line"> 6  </div><div class="line"> 7  [stillImageSource addTarget:lookupFilter];</div><div class="line"> 8  [lookupImageSource addTarget:lookupFilter];</div><div class="line"> 9  if (self.hasVignetteEffect) &#123;</div><div class="line">10      [lookupFilter useNextFrameForImageCapture];</div><div class="line">11      GPUImageVignetteFilter *vignettefilter = [[GPUImageVignetteFilter alloc] init];</div><div class="line">12      vignettefilter.vignetteEnd = kAlohaImageVignetteEnd;</div><div class="line">13      vignettefilter.vignetteStart = kAlohaImageVignetteStart;</div><div class="line">14      </div><div class="line">15      [lookupFilter addTarget:vignettefilter];</div><div class="line">16      [stillImageSource processImage];</div><div class="line">17      [lookupImageSource processImage];</div><div class="line">18      [vignettefilter useNextFrameForImageCapture];</div><div class="line">19      UIImage *filteredimage = [vignettefilter imageFromCurrentFramebuffer];</div><div class="line">20      return filteredimage;</div><div class="line">21  &#125; else &#123;</div><div class="line">22      [stillImageSource processImage];</div><div class="line">23      [lookupImageSource processImage];</div><div class="line">24      [lookupFilter useNextFrameForImageCapture];</div><div class="line">25      UIImage *filteredimage = [lookupFilter imageFromCurrentFramebuffer];</div><div class="line">26      return filteredimage;</div><div class="line">27  &#125;</div><div class="line">28 &#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://dupengfei.com/2015/10/14/GPUimage(二)自定义滤镜/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="杜鹏飞">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杜鹏飞的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/10/14/GPUimage(二)自定义滤镜/" itemprop="url">
                  GPUImage（二）自定义滤镜
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-14T18:32:33+08:00">
                2015-10-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GPUImage/" itemprop="url" rel="index">
                    <span itemprop="name">GPUImage</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/10/14/GPUimage(二)自定义滤镜/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/14/GPUimage(二)自定义滤镜/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="自定义滤镜"><a href="#自定义滤镜" class="headerlink" title="自定义滤镜"></a>自定义滤镜</h2><p>GPUImage 自定义滤镜需要使用 OpenGL 着色语言( GLSL )编写 Fragment Shader（片段着色器），除此之外你可能还需要一点点图像处理相关的知识。下面我将尝试通过 GPUImage 中的 GPUImageColorInvertFilter(反色滤镜)来讲解一下它的运作过程。</p>
<p>先看.h 文件:   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#import “GPUImageFilter.h&quot;</div><div class="line"></div><div class="line">@interface GPUImageColorInvertFilter : GPUImageFilter</div><div class="line">&#123;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>很简单，可以看出 GPUImageColorInvertFilter 是继承了 GPUImageFilter<br>然后看 .m 文件 中 @implementation 之前的一段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">NSString *const kGPUImageInvertFragmentShaderString = SHADER_STRING</div><div class="line">(</div><div class="line"> varying highp vec2 textureCoordinate;</div><div class="line"></div><div class="line"> uniform sampler2D inputImageTexture;</div><div class="line"></div><div class="line"> void main()</div><div class="line"> &#123;</div><div class="line">    lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);</div><div class="line"></div><div class="line">    gl_FragColor = vec4((1.0 - textureColor.rgb), textureColor.a);</div><div class="line"> &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>第 1 行，可以看到 SHADER_STRING 宏中包含着我们的 Shader (着色器)代码，我们的着色器字符串赋给一个 const NSString 对象（这个常量将在 GPUImageFilter 及其子类的初始化过程中用来设置 filter）。</p>
<p>第 2、3 行声明了两个变量。</p>
<p><strong>varying</strong> 变量是<strong>Vertex</strong> 和 <strong>Fragment Shader</strong>（顶点着色器和片段着色器）之间做数据传递用的，一般 Vertex Shader（顶点着色器） 修改 varying 变量的值，然后 Fragment Shader（片段着色器）使用该varying变量的值。因此varying 变量在 Vertex 和 Fragment Shader 中声明必须一致。放到这里，也就是说 textureCoordinate 必须叫这个名字不能改。  </p>
<p><strong>highp</strong> 声明 textureCoordinate 精度（相应的还有mediump和lowp）。 </p>
<p><strong>vec2</strong> 声明textureCoordinate 是一个二维向量。  </p>
<p><strong>uniform</strong> 声明 inputImageTexture 是外部程序传递给 Shader 的变量， Shader 程序内部只能用，不能改。</p>
<p><strong>sampler2D</strong> 声明变量是一个2D纹理。  </p>
<p>第 4 行，相信你并不陌生，没错儿 Shader 也是从 main() 函数开始执行的。</p>
<p>第 5 行，texture2D 纹理取样器，根据纹理坐标返回纹理单元的值。</p>
<p>第 6 行，(1.0 - textureColor.rgb) 去 textureColor也就是原图的 RGB 值，做了一个向量的减法，这是图像的反色算法，然后把经过反色的 RGB 值和原图的 Alpha 值组成一个新的 vec4（四维向量）值赋给 gl_FragColor。 gl_FragColor 是 Fragment Shader 预先定义的变量，赋给它的值就是该片段最终的颜色值。</p>
<p>Shader 到这里已经解释完了，我来说一下我对这部分功能的理解，方便你理解：GPUImage 中应该有一个 Vertex Shader，它对图像逐个像素扫描，通过 textureCoordinate 变量将当前的扫描坐标传递给我们的 Fragment Shader，inputImageTexture 包含我们要处理的图像的全部信息，在 Shader 程序内部通过 texture2D 得到 inputImageTexture 在当前位置 textureCoordinate 的 RGBA 值，运用图像处理知识，算出想要的新的 RGBA 值，把结果值赋给 gl_FragColor就算完成了。</p>
<p>现在我们继续看代码，在 Shader 之后是 GPUImageColorInvertFilter 的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@implementation GPUImageColorInvertFilter</div><div class="line"></div><div class="line">- (id)init;</div><div class="line">&#123;</div><div class="line">    if (!(self = [super initWithFragmentShaderFromString:kGPUImageInvertFragmentShaderString]))</div><div class="line">    &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>很简单，就是使用刚才的着色器代码来设置 filter。这样一个新的滤镜就诞生了～</p>
<p>也可以从bundle里面加载OpenGL Shading Language编写的 fragment shader文件, 后缀是 .fsh  或者从字符串里面加载.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1. GPUImageFilter *customFilter = [[GPUImageFilter alloc] initWithFragmentShaderFromFile:@&quot;CustomShader&quot;];</div><div class="line"></div><div class="line">1. NSString *const kfilterShader = SHADER_STRING</div><div class="line">2. (</div><div class="line">3. ...</div><div class="line">4. );</div></pre></td></tr></table></figure>
<p>一个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">1. varying highp vec2 textureCoordinate;</div><div class="line">2. uniform sampler2D inputImageTexture;</div><div class="line">3. void main()</div><div class="line">4. &#123;</div><div class="line">5.     lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);</div><div class="line">6.     lowp vec4 outputColor;</div><div class="line">7.     outputColor.r = (textureColor.r * 0.393) + (textureColor.g * 0.769) + (textureColor.b * 0.189);</div><div class="line">8.     outputColor.g = (textureColor.r * 0.349) + (textureColor.g * 0.686) + (textureColor.b * 0.168);    </div><div class="line">9.     outputColor.b = (textureColor.r * 0.272) + (textureColor.g * 0.534) + (textureColor.b * 0.131);</div><div class="line">10.     outputColor.a = 1.0;</div><div class="line">11.     gl_FragColor = outputColor;</div><div class="line">12. &#125;</div></pre></td></tr></table></figure>
<p>这段脚本有一个varing, 表示的是材质的2D坐标, 一个unifrom是材质的图片.<br>main函数里面把这个坐标的颜色取出来处理后生成新的颜色, 交给gl_FragColor传递个pipeline的下一个单元. 在这里也就是最终输出.</p>
<p>但是自己没有openGL基础，如果想要开发滤镜也会非常困难。下一篇就讲一下如何快速开发滤镜。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://dupengfei.com/2015/10/07/GPUimage(一)简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="杜鹏飞">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杜鹏飞的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/10/07/GPUimage(一)简介/" itemprop="url">
                  GPUImage（一）简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-07T17:30:48+08:00">
                2015-10-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GPUImage/" itemprop="url" rel="index">
                    <span itemprop="name">GPUImage</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/10/07/GPUimage(一)简介/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/07/GPUimage(一)简介/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="GPUImage简介"><a href="#GPUImage简介" class="headerlink" title="GPUImage简介"></a>GPUImage简介</h2><p>GPUImage 是一个基于 GPU 图像和视频处理的开源 iOS 框架。由于使用 GPU 来处理图像和视频，所以速度非常快，它的作者 BradLarson 称在 iPhone4 上其处理速度是使用 CPU 来处理的 100 倍 (CoreImage 也能使用 GPU 来处理图像，但我觉得 CoreImage 还是慢)。除了速度上的优势，GPUImage 还提供了很多很棒的图像处理滤镜，但有时候这些基本功能仍然无法满足实际开发中的需求，不用担心 GPUImage 支持自定义滤镜。</p>
<h2 id="安装GPUImage"><a href="#安装GPUImage" class="headerlink" title="安装GPUImage"></a>安装GPUImage</h2><ol>
<li>把GPUImage.xcodeproj 拖到你的Xcode project</li>
<li>在app的target依赖设置里面添加GPUImage作为Target Dependency</li>
<li>在build phase的Link Binary With Libraries, 把libGPUImage.a加进来.</li>
<li>添加下面这些系统framework:<br>CoreMedia<br>CoreVideo<br>OpenGLES<br>AVFoundation<br>QuartzCore  </li>
<li>头文件搜索路径: project’s build settings, 把GPUImage的source和source下的iOS目录加到搜索路径里, 使用相对路径和递归.</li>
<li>包含下面这个头文件:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#import &quot;GPUImage.h&quot;</div></pre></td></tr></table></figure>
<h2 id="GPUImage的简单使用"><a href="#GPUImage的简单使用" class="headerlink" title="GPUImage的简单使用"></a>GPUImage的简单使用</h2><h3 id="GPUImage中的有几个概念"><a href="#GPUImage中的有几个概念" class="headerlink" title="GPUImage中的有几个概念"></a>GPUImage中的有几个概念</h3><p>⁃ output，输出源</p>
<p>⁃ intput，输入源</p>
<p>⁃ filter，滤镜</p>
<p>所以一个完整的滤镜处理流程是: output+X+input，X就是滤镜组(1+个滤镜)。GPUImage为了方便，新版本中提供了GPUImageFilterPipeline 这个东西，方便用户使用多个滤镜组合，不用担心前后的链式逻辑。</p>
<p>输入源是一些GPUImageOutput的子类.包括:<br>(1). GPUImageVideoCamera (for live video from an iOS camera)<br>(2.) GPUImageStillCamera (for taking photos with the camera)<br>(3). GPUImagePicture (for still images)<br>(4). GPUImageMovie (for movies). S  </p>
<p>输出源可以是GPUImageView, 或者GPUImageMovieWriter<br>一个典型的例子   </p>
<ol>
<li>GPUImageVideoCamera -&gt; GPUImageSepiaFilter -&gt; GPUImageView<h3 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h3>在使用GPUImage之前先做些准备工作。OpenGL ES程序来处理图片，会有以下几个步骤：<br>1、初始化OpenGL ES环境，编译、链接顶点着色器和片元着色器；<br>2、缓存顶点、纹理坐标数据，传送图像数据到GPU；<br>3、绘制图元到特定的帧缓存；<br>4、在帧缓存取出绘制的图像。<br>GPUImage里面有两个非常重要的类：<br><strong>1 GPUImageFilter</strong>负责的是第一、二、三步。<br><strong>2 GPUImageFramebuffer</strong>负责是第四步。</li>
</ol>
<h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><p>将GPUImageView设置为self.view，根据face.png，设置GPUImagePicture，然后添加GPUImageTiltShiftFilter到响应链，再把GPUImageView作为响应链的终点，最后调用processImage，开始处理图像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">GPUImageView *primaryView = [[GPUImageView alloc] initWithFrame:self.view.frame];</div><div class="line">    self.view = primaryView;</div><div class="line">    UIImage *inputImage = [UIImage imageNamed:@&quot;face.png&quot;];</div><div class="line">    _sourcePicture = [[GPUImagePicture alloc] initWithImage:inputImage];</div><div class="line">    _sepiaFilter = [[GPUImageTiltShiftFilter alloc] init];</div><div class="line">    _sepiaFilter.blurRadiusInPixels = 40.0;</div><div class="line">    [_sepiaFilter forceProcessingAtSize:primaryView.sizeInPixels];</div><div class="line">    [_sourcePicture addTarget:_sepiaFilter];</div><div class="line">    [_sepiaFilter addTarget:primaryView];</div><div class="line">    [_sourcePicture processImage];</div></pre></td></tr></table></figure></p>
<p>使用GPUImage自带的滤镜是远远不能满足需求的，下一篇就要看一下自定义滤镜。</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>项目里，发现滤镜模块调用完了以后，内存上去了下不来，反复检查，所有GPUImage相关元素都已经释放了。后来想到了显存，arc环境下，只负责回收oc对象的内存，显存自然需要GPUImage使用者自己来回收，这样也就容易了，翻GPUImage的api，知道</p>
<p>GPUImageContext中有个framebufferCache：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[GPUImageContextsharedImageProcessingContext].framebufferCachepurgeAllUnassignedFramebuffers]</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://dupengfei.com/2015/06/17/block深究/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="杜鹏飞">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杜鹏飞的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/06/17/block深究/" itemprop="url">
                  Block深究
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-06-17T18:32:11+08:00">
                2015-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/06/17/block深究/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/06/17/block深究/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <!--
## 目录

*   ##### 什么是block？

    *   block编译转换结构
    *   block实际结构

*   ##### block的类型

    *   NSConcreteGlobalBlock和NSConcreteStackBlock
    *   NSConcreteMallocBlock

*   ##### 捕捉变量对block结构的影响

    *   局部变量
    *   全局变量
    *   局部静态变量
    *   __block修饰的变量
    *   self隐式循环引用

*   ##### 不同类型block的复制

    *   栈block
    *   堆block
    *   全局block

*   ##### block辅助函数

    *   __block修饰的基本类型的辅助函数
    *   对象的辅助函数

*   ##### ARC中block的工作

    *   block试验
    *   block作为参数传递
    *   block作为返回值
    *   block属性

### 参考博文-->
<p>关于block网上也是一大把的文章，但总觉得有的说的太深有的说的太浅。最近看了一些block的资料，并动手做了一些实践，摘录并添加了一些结论。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2015/06/17/block深究/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://dupengfei.com/2015/01/27/ViewController生命周期/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="杜鹏飞">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杜鹏飞的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/01/27/ViewController生命周期/" itemprop="url">
                  ViewController生命周期
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-01-27T00:38:40+08:00">
                2015-01-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/01/27/ViewController生命周期/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/01/27/ViewController生命周期/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ViewController的生命周期"><a href="#ViewController的生命周期" class="headerlink" title="ViewController的生命周期"></a>ViewController的生命周期</h1><h3 id="ARC环境"><a href="#ARC环境" class="headerlink" title="ARC环境"></a>ARC环境</h3><ul>
<li><h4 id="单个viewController的生命周期"><a href="#单个viewController的生命周期" class="headerlink" title="单个viewController的生命周期"></a>单个viewController的生命周期</h4><ul>
<li>initWithCoder:(NSCoder *)aDecoder：（如果使用storyboard或者xib）</li>
<li>loadView：加载view</li>
<li>viewDidLoad：view加载完毕</li>
<li>viewWillAppear：控制器的view将要显示</li>
<li>viewWillLayoutSubviews：控制器的view将要布局子控件</li>
<li>viewDidLayoutSubviews：控制器的view布局子控件完成<br>这期间系统可能会多次调用viewWillLayoutSubviews 、 viewDidLayoutSubviews 俩个方法</li>
<li>viewDidAppear:控制器的view完全显示</li>
<li>viewWillDisappear：控制器的view即将消失的时候这期间系统也会调用viewWillLayoutSubviews 、viewDidLayoutSubviews 两个方法</li>
<li>viewDidDisappear：控制器的view完全消失的时候</li>
</ul>
</li>
<li><h4 id="多个viewControllers跳转"><a href="#多个viewControllers跳转" class="headerlink" title="多个viewControllers跳转"></a>多个viewControllers跳转</h4><ul>
<li>当我们点击push的时候首先会加载下一个界面然后才会调用界面的消失方法</li>
<li>initWithCoder:(NSCoder *)aDecoder：ViewController2 (如果用xib创建的情况下）</li>
<li>loadView：ViewController2</li>
<li>viewDidLoad：ViewController2</li>
<li>viewWillDisappear：ViewController1 将要消失</li>
<li>viewWillAppear：ViewController2 将要出现</li>
<li>viewWillLayoutSubviews ViewController2</li>
<li>viewDidLayoutSubviews ViewController2</li>
<li>viewWillLayoutSubviews:ViewController1</li>
<li>viewDidLayoutSubviews:ViewController1</li>
<li>viewDidDisappear:ViewController1 完全消失</li>
<li>viewDidAppear:ViewController2 完全出现</li>
</ul>
</li>
<li><h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p>-整个控制器声明周期： viewDidLoad -&gt; viewWillAppear -&gt; viewWillLayoutSubviews -&gt; viewDidLayoutSubviews -&gt; viewDidAppear -&gt; viewWillDisappear -&gt; viewDidDisappear</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  

          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="杜鹏飞" />
          <p class="site-author-name" itemprop="name">杜鹏飞</p>
           
              <p class="site-description motion-element" itemprop="description">一个非常nice的iOS开发 😄</p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/dupengfei" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://plus.google.com/u/0/117309292640302365524" target="_blank" title="G+">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  G+
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">杜鹏飞</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"dupengfei"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  

  

  

  

  


  

</body>
</html>
