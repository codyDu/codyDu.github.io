<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="数据结构与算法," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="一、栈栈是只能在一端进行插入和删除的线性表。 （别看只是个定义，非常重要，已经道出了运算方法：只能在一端插入和删除。)

栈的特征：后进先出，先进后出。

插入和删除元素的一端称为栈顶。（说明了我们在栈顶操作） 另一端称为栈底。 插入元素和删除元素的操作称为入栈和出栈。
1.顺序栈结构：(top总是指向数组最后的元素，比如data[n]，而不是前面)
123456#define MAXSIZE 1">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构常见操作与总结">
<meta property="og:url" content="http://dupengfei.com/2016/05/21/数据结构常见操作与总结/index.html">
<meta property="og:site_name" content="杜鹏飞的博客">
<meta property="og:description" content="一、栈栈是只能在一端进行插入和删除的线性表。 （别看只是个定义，非常重要，已经道出了运算方法：只能在一端插入和删除。)

栈的特征：后进先出，先进后出。

插入和删除元素的一端称为栈顶。（说明了我们在栈顶操作） 另一端称为栈底。 插入元素和删除元素的操作称为入栈和出栈。
1.顺序栈结构：(top总是指向数组最后的元素，比如data[n]，而不是前面)
123456#define MAXSIZE 1">
<meta property="og:updated_time" content="2017-03-16T16:42:16.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据结构常见操作与总结">
<meta name="twitter:description" content="一、栈栈是只能在一端进行插入和删除的线性表。 （别看只是个定义，非常重要，已经道出了运算方法：只能在一端插入和删除。)

栈的特征：后进先出，先进后出。

插入和删除元素的一端称为栈顶。（说明了我们在栈顶操作） 另一端称为栈底。 插入元素和删除元素的操作称为入栈和出栈。
1.顺序栈结构：(top总是指向数组最后的元素，比如data[n]，而不是前面)
123456#define MAXSIZE 1">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://dupengfei.com/2016/05/21/数据结构常见操作与总结/"/>





  <title> 数据结构常见操作与总结 | 杜鹏飞的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b627bfa0d9d39ca04a7102b636415274";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">杜鹏飞的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录一些，分享一些，欢迎交流    Hosted by Coding Pages</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://dupengfei.com/2016/05/21/数据结构常见操作与总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="杜鹏飞">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杜鹏飞的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                数据结构常见操作与总结
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-21T00:34:10+08:00">
                2016-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/05/21/数据结构常见操作与总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/21/数据结构常见操作与总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="一、栈"><a href="#一、栈" class="headerlink" title="一、栈"></a>一、栈</h1><p>栈是只能在一端进行插入和删除的线性表。 （别看只是个定义，非常重要，已经道出了运算方法：只能在一端插入和删除。)</p>
<blockquote>
<p>栈的特征：后进先出，先进后出。</p>
</blockquote>
<p>插入和删除元素的一端称为栈顶。（说明了我们在栈顶操作） 另一端称为栈底。 插入元素和删除元素的操作称为入栈和出栈。</p>
<h3 id="1-顺序栈"><a href="#1-顺序栈" class="headerlink" title="1.顺序栈"></a>1.顺序栈</h3><p>结构：(top总是指向数组最后的元素，比如data[n]，而不是前面)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#define MAXSIZE 100</div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">    elementtype data[MAXSIZE];</div><div class="line">    int top;</div><div class="line">&#125; seqstack;</div></pre></td></tr></table></figure>
<p>初始化栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void init_stack(seqstack *S)</div><div class="line">&#123;</div><div class="line">    S-&gt;top = -1;    //一个元素也没有，注意因为TOP是下标而不是元素个数，用-1</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>判断栈是否为空：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int stack_empty(seqstack *S)</div><div class="line">&#123;</div><div class="line">    if (S-&gt;top == -1)</div><div class="line">        return 1;</div><div class="line">    else</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>取栈顶元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">elementtype stack_top(seqstack *S)</div><div class="line">&#123;</div><div class="line">    if (stack_empty(S))</div><div class="line">        error(&quot;栈为空！&quot;);</div><div class="line">    else</div><div class="line">        return S-&gt;data[S-&gt;top];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>入栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void push_stack(seqstack *S, elementtype x)</div><div class="line">&#123;</div><div class="line">    if (S-&gt;top == MAXSIZE -1)</div><div class="line">        error(&quot;溢出！&quot;);</div><div class="line">    else</div><div class="line">        S-&gt;data[++S-&gt;top] = x;    //注意-&gt;运算符的优先级是最高的</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>出栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">elementtype pop_stack(seqstack *S)</div><div class="line">&#123;</div><div class="line">    if (stack_empty(S))</div><div class="line">        error(&quot;栈为空！&quot;);</div><div class="line">    else</div><div class="line">        return S-&gt;data[S-&gt;top--];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>判断栈是否为满：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int stack_full(seqstack *S)</div><div class="line">&#123;</div><div class="line">    if (S-&gt;top == MAXSIZE -1)</div><div class="line">        return 1;</div><div class="line">    else</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总体来说，顺序栈很简单，出的时候取最后的元素，进的时候一样进在尾部。</p>
<h3 id="2-链栈"><a href="#2-链栈" class="headerlink" title="2.链栈"></a>2.链栈</h3><p>栈的链式存储结构称为链栈。 其插入和删除操作仅限制在表头位置上进行。 由于只能在链表头部进行操作，故链栈没有必要象单链表那样添加头结点。栈顶指针就是链表的头指针。 结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct node    //和一般链表的结构一样。</div><div class="line">&#123;</div><div class="line">    elementtype data;</div><div class="line">    struct node *next;</div><div class="line">&#125; linkstack; </div><div class="line">linkstack *top;</div><div class="line">当top=NULL时，链栈为空栈。</div></pre></td></tr></table></figure>
<p>入栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void push_stack(linkstack *top, elementtype x)</div><div class="line">&#123;</div><div class="line">    linkstack *P = (linkstack *)malloc(sizeof(linkstack));</div><div class="line">    P-&gt;data = x;</div><div class="line">    P-&gt;next = top-&gt;next;</div><div class="line">    top = P;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>出栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">elementype pop_stack(linkstack *top)</div><div class="line">&#123;</div><div class="line">    elementtype x;</div><div class="line">    linkstack *P;</div><div class="line">    if (top == NULL)</div><div class="line">        error(&quot;栈为空！&quot;);</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        x = top-&gt;data;</div><div class="line">        P = top;</div><div class="line">        top = top-&gt;next;</div><div class="line">        free(P);</div><div class="line">        return x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="二、队列"><a href="#二、队列" class="headerlink" title="二、队列"></a>二、队列</h1><p>队列是只能在一端插入，另一端删除的线性表。 特征是：先进先出，后进后出。</p>
<h1 id="1-顺序队列"><a href="#1-顺序队列" class="headerlink" title="1.顺序队列"></a>1.顺序队列</h1><p>注意顺序队列多是循环队列，这里要注意几点：</p>
<ul>
<li>(1)front是队头的前一个位置。</li>
<li>(2)尾部入队，头部出队。</li>
<li><p>(3)由于循环，任何的位置移动计算之后要取余：P = (P + 1) % MAXSIZE 。 结构：</p>
<p>#define MAXSIZE 100 typedef struct { elementtype data[MAXSIZE]; int front; //头序号（注意是队头的前一个位置） int rear; //尾序号（直接指向尾元素） } seqqueue;</p>
</li>
</ul>
<p>初始化队列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void init_queue(seqqueue *Q)</div><div class="line">&#123;</div><div class="line">    Q-&gt;front = 0;</div><div class="line">    Q-&gt;rear = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有一种写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void init_queue(seqqueue *Q)</div><div class="line">&#123;</div><div class="line">    Q-&gt;front = MAXSIZE - 1;</div><div class="line">    Q-&gt;rear = MAXSIZE - 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>两种方法的区别是第一种插入第一个元素是data[1]，而第二种是data[0]。 判断队列是否为空：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int queue_empty(seqqueue *Q)</div><div class="line">&#123;</div><div class="line">    if (Q-&gt;front == Q-&gt;rear)</div><div class="line">        return 1;</div><div class="line">    else</div><div class="line">        return -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>判断队列是否为满：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int queue_full(seqqueue *Q)</div><div class="line">&#123;</div><div class="line">    if ((Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front)</div><div class="line">        return 1;</div><div class="line">    else</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>取队头元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">elementtype queue_front(seqqueue *Q)</div><div class="line">&#123;</div><div class="line">    if (queue_empty(Q))</div><div class="line">        error(&quot;队列为空！&quot;);</div><div class="line">    else</div><div class="line">        return Q-&gt;data[(Q-&gt;front + 1) % MAXSIZE];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>入队：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void Enqueue(seqqueue *Q, elementtype x)</div><div class="line">&#123;</div><div class="line">    if (queue_full(Q))</div><div class="line">        error(&quot;队列满！&quot;);</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE;    //千万不能直接用Q-&gt;rear++，在循环队列要特别注意</div><div class="line">        Q-&gt;data[Q-&gt;rear] = x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>出队：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">elementtype Outqueue(seqqueue *Q)</div><div class="line">&#123;</div><div class="line">    if (queue_empty(Q))</div><div class="line">        error(&quot;队列为空！&quot;);</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE;</div><div class="line">        return Q-&gt;data[Q-&gt;front];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-链队列"><a href="#2-链队列" class="headerlink" title="2.链队列"></a>2.链队列</h3><p>出队时，删除表头操作，入队时，在表尾添加结点。（也就是头部出，尾部进） 使用带头结点的单链表形式。（注意链栈是不带头结点的） 结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">typedef struct mynode</div><div class="line">&#123;</div><div class="line">    elementtype data;</div><div class="line">    mynode *next;</div><div class="line">&#125; node;    //就是单链表</div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">    node *front;</div><div class="line">    node *rear;</div><div class="line">&#125; linkqueue;</div></pre></td></tr></table></figure>
<p>初始化队列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void init_queue(linkqueue *Q)</div><div class="line">&#123;</div><div class="line">    Q-&gt;front = (node *)malloc(sizeof(node));    //生成头结点（注意是NODE类型，Q结构是已有的一个结构，这里有点特殊，仔细体会）</div><div class="line">    Q-&gt;rear = Q-&gt;front;</div><div class="line">    Q-&gt;front = NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>判断队列是否为空：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int queue_empty(linkqueue *Q)</div><div class="line">&#123;</div><div class="line">    if (Q-&gt;front == Q-&gt;rear)</div><div class="line">        return 1;</div><div class="line">    else</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>取队头元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">elementtype queue_front(linkqueue *Q)</div><div class="line">&#123;</div><div class="line">    if (queue_empty(Q))</div><div class="line">        error(&quot;队列为空！&quot;);</div><div class="line">    else</div><div class="line">        return Q-&gt;front-&gt;next-&gt;data;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>入队：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void Enqueue(linkqueue *Q, elementtype x)</div><div class="line">&#123;</div><div class="line">    node *P = (node *)malloc(sizeof(node));</div><div class="line">    P-&gt;data = x;</div><div class="line">    P-&gt;next = NULL;</div><div class="line">    Q-&gt;rear-&gt;next = P;</div><div class="line">    Q-&gt;rear = P;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>出队：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">elementtype Outqueue(linkqueue *Q)</div><div class="line">&#123;</div><div class="line">    node *P;</div><div class="line">    elmenttype x;</div><div class="line">    if (queue_empty(Q))</div><div class="line">        error(&quot;队列为空！&quot;);</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        P = Q-&gt;front-&gt;next;</div><div class="line">        Q-&gt;front-&gt;next = P-&gt;next;</div><div class="line">        x = P-&gt;data;</div><div class="line">        free(P);</div><div class="line">    &#125;</div><div class="line">    if (Q-&gt;front-&gt;next == NULL)    //只剩一个结点删除后队列为空时的特殊情况，一定要注意处理</div><div class="line">        Q-&gt;rear = Q-&gt;front;</div><div class="line">    return x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>主要是稀疏矩阵的压缩存储： 当数组中非零元素非常少时，称之为稀疏矩阵。 存储特别如下：</p>
<ul>
<li>(1)对稀疏矩阵压缩存储时，除了存储非零元素的值v以外，还要存储其行列号i和j，故每个元素对应一个三元组(i, j, v)。将这些元素的三元组组织起来构成三元组表。</li>
<li>(2)需要在三元组表中增设元素个数、行列数，以唯一确定一个稀疏矩阵。</li>
</ul>
<p>结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#define MAXSIZE 100</div><div class="line">typedef struct    //三元组结构</div><div class="line">&#123;</div><div class="line">    int i, j;</div><div class="line">    elementtype v;</div><div class="line">&#125; tuple;</div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">    int mu, nu, tu;    //行数、列数、非0元素个数</div><div class="line">    tuple data[MAXSIZE];</div><div class="line">&#125; spmatrix;</div></pre></td></tr></table></figure>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h3 id="一、树"><a href="#一、树" class="headerlink" title="一、树"></a>一、树</h3><p>树中的每个结点最多只有一个前驱（父辈），但可能有多个后继（后代）。 一个结点的度是指该结点的孩子数目。 若一个结点的度为0，称为叶子结点或终结点，否则称为分支结点或非终结点。 一棵树的度是树中最大的结点的度。 某个结点的子树的根称为其孩子结点，而该结点为其孩子结点的双亲结点或父结点。 同一个结点的孩子互相称为兄弟结点。 根的层次为1，其余结点的层次为父结点的层次数加1，而最大的层次数称为树的高度或深度。 如果树中各兄弟结点之间的排列次序是无关的，则称之为有序树，否则称为无序树。 称多棵树为森林。</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树和树一样，都可以为空树。 注意二叉树每个结点的孩子都有左右之分，每个结点都有左右两个子树，这与树结构明显不同。 二叉树和树本质上是完全不同的两种结构。 定义：满二叉树是指每层都有最大数目结点的二叉树，即高度为k的满二叉树中有2k-1个结点。而完全二叉树则是指在满二叉树的最下层从右到左连续地删除若干个结点所得到的二叉树。</p>
<p>二叉树的性质：</p>
<ul>
<li>1.在二叉树的第i层上的结点个数&lt;=2i-1(i&gt;0)</li>
<li>2.深度（高度）为k的二叉树的结点个数&lt;=2k-1</li>
<li>3.对任一棵非空的二叉树，如果其叶子数为n0, 度为2的结点数为n2, 则有下面的关系式成立：n0=n2+1 (这个性质很重要。主要是有个概念：除去根结点，每个结点都与一个它上面的分支一一对应，也就是说，结点数＝分支数＋1，所以有：n-1=n1+2*n2)</li>
<li>4.有n个结点的完全二叉树(n&gt;0)的深度为[log2n]+1([]为取整)</li>
<li>5.在编号的完全二叉树中，各结点的编号之间的关系为： 编号为i的结点如果存在左孩子，则其编号为2i，如果存在右孩子，则其编号为2i+1，如果存在父结点，则其编号为[i/2]。</li>
</ul>
<p>二叉树的存储结构： 1.顺序存储结构： 按完全二叉树的编号次序进行，即编号为i的结点存储在数组中下标为i的元素中。 缺点：若二叉树不是完全二叉树，则为了保持结点之间的关系，不得不空出许多元素来，这就造成了空间的浪费。</p>
<p>2.二叉链表存储结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef struct node</div><div class="line">&#123;</div><div class="line">    datatype data;</div><div class="line">    struct node *lchild, *rchild;</div><div class="line">&#125; bitree;</div></pre></td></tr></table></figure>
<h3 id="二叉树的遍历："><a href="#二叉树的遍历：" class="headerlink" title="二叉树的遍历："></a>二叉树的遍历：</h3><p>所谓遍历二叉树是指按某种次序访问二叉树中每个结点一次且仅一次。 根据访问根结点的次序，可以分为先序遍历，中序遍历，后序遍历。 先序遍历可描述为： 若二叉树T不为空：</p>
<ul>
<li>(1)访问T的根结点；</li>
<li>(2)先序遍历T的左子树；</li>
<li><p>(3)先序遍历T的右子树。 遍历的算法非常简单，只写出先序遍历算法：</p>
<p>void preorder(bitree *T) { if (T != NULL) { visit(T); //一般用的最多的就是输出 preorder(T-&gt;lchild); preorder(T-&gt;rchild); } }</p>
</li>
</ul>
<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>线索二叉树主要是为了求解在某种次序下的前驱或后继结点。 将二叉树各结点中的空的左孩子指针域改为指向其前驱，空的右孩子指针域改为指向其后继。称这种新的指针（前驱或后继）为线索，所得到的二叉树被称为线索二叉树，将二叉树转变成线索二叉树的过程称为线索化。 同时，为了区分到底指针是指向前驱（后继）还是孩子，要加入两个标志来判断。 结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef struct node</div><div class="line">&#123;</div><div class="line">    int ltag, rtag;    //0为孩子，1为前驱或后继</div><div class="line">    datatype data;</div><div class="line">    struct node *lchild, *rchild;</div><div class="line">&#125; ordertree;</div></pre></td></tr></table></figure>
<p>先序后继的求解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ordertree *presuc(ordertree *P)</div><div class="line">&#123;</div><div class="line">    if (P-&gt;ltag == 0)</div><div class="line">        return P-&gt;lchild;</div><div class="line">    else</div><div class="line">        return P-&gt;rchild;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>中序后继：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">ordertree *insuc(ordertree *P)</div><div class="line">&#123;</div><div class="line">    ordertree *q = P-&gt;rchild;</div><div class="line">    if (P-&gt;rtag == 1)</div><div class="line">        return q;</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        while (q-&gt;ltag == 0)</div><div class="line">            q = q-&gt;lchild;</div><div class="line">        return q;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>中序先驱：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">ordertree *infore(ordertree *P)</div><div class="line">&#123;</div><div class="line">    ordertree *q = P-&gt;lchild;</div><div class="line">    if (P-&gt;ltag == 1)</div><div class="line">        return q;</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        while (q-&gt;rtag == 0)</div><div class="line">            q = q-&gt;rchild;</div><div class="line">        return q;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>后序先驱：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ordertree *postfore(ordertree *P)</div><div class="line">&#123;</div><div class="line">    if (P-&gt;rtag == 0)</div><div class="line">        return P-&gt;rchild;</div><div class="line">    else</div><div class="line">        return P-&gt;lchild;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h3><h5 id="1-树的存储结构："><a href="#1-树的存储结构：" class="headerlink" title="1.树的存储结构："></a>1.树的存储结构：</h5><p>(1)双亲表示法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct tnode</div><div class="line">&#123;</div><div class="line">    datatype data;</div><div class="line">    int parent;</div><div class="line">&#125;</div><div class="line">struct tnode treelist[MAXSIZE];    //整个树的存储数组说明</div></pre></td></tr></table></figure>
<p>其中parent指示该结点父结点的下标，data存放结点的值。 优点：便于搜索相应结点的父结点和祖先结点。 缺点：若要搜索孩子结点或后代结点需要搜索整个表，浪费时间。</p>
<p>(2)孩子链表表示法 分别将每个结点的孩子结点连成一个链表，然后将各表头指针放在一个表中构成一个整体结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">typedef struct node    //链表中每个孩子结点的定义</div><div class="line">&#123;</div><div class="line">    int data;</div><div class="line">    struct node *next;</div><div class="line">&#125; listnode;</div><div class="line">typedef struct    //数组元素的定义，每个数组元素都是一个单链表，单头元素不同</div><div class="line">&#123;</div><div class="line">    datatype info;</div><div class="line">    listnode *firstchild;</div><div class="line">&#125; arrnode;</div><div class="line">arrnode tree[MAXSIZE];    //MAXSIZE为所有结点的个数</div></pre></td></tr></table></figure>
<p>优缺点：与双亲表示法恰好相反。</p>
<p>(3)孩子－兄弟链表表示法（二叉链表表示法，二叉树表示法） 树中每个结点用一个链表结点来存储，每个链表结点中除了存放结点的值外，还有两个指针，一个用来指示该结点的第一个孩子，另一个用于指示该结点的下一个兄弟结点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef struct node</div><div class="line">&#123;</div><div class="line">    datatype data;</div><div class="line">    struct node *firstchild, *nextbrother;</div><div class="line">&#125; tnode;</div></pre></td></tr></table></figure>
<h5 id="2-树（森林）与二叉树的转换"><a href="#2-树（森林）与二叉树的转换" class="headerlink" title="2.树（森林）与二叉树的转换"></a>2.树（森林）与二叉树的转换</h5><p>树或森林的子树转换为二叉树的左子树，兄弟转化为右子树。</p>
<h5 id="3-树（森林）的遍历"><a href="#3-树（森林）的遍历" class="headerlink" title="3.树（森林）的遍历"></a>3.树（森林）的遍历</h5><p>树的遍历可分为先序遍历和后序遍历。（注意没有中序，因为树有不只两个孩子）即结点是在其子树之前还是之后访问。 遍历树（森林）要转换为遍历其对应的二叉树： 先序遍历：（同二叉树的先序遍历）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void preorder(tnode *T)</div><div class="line">&#123;</div><div class="line">    if (T != NULL)</div><div class="line">    &#123;</div><div class="line">        visit(T);</div><div class="line">        preorder(T-&gt;firstchild);</div><div class="line">        preorder(T-&gt;nextbrother);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>后序遍历：（同二叉树的中序遍历）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void postorder(tnode *T)</div><div class="line">&#123;</div><div class="line">    if (T != NULL)</div><div class="line">    &#123;</div><div class="line">        postorder(T-&gt;firstchild);</div><div class="line">        visit(T);</div><div class="line">        postorder(T-&gt;nextbrother);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p>哈夫曼树主要用来处理压缩算法。 一般的判断问题的流程就象是一棵二叉树，其中分支（判断）结点对应于二叉树的分支结点；而最后得出的结论对应于叶子结点；一个结论所需要的判断次数是从根结点到该叶子结点的分支线数（层次数-1）；每个结论成立的次数作为叶子结点的权值。 (这个权值可能比较少接触,但是其实它非常重要,因为我们平时设计的系统,判断的结果常常都是通过长年的实践会有一个出现机率分配,而不可能是平分的,比如考试,如果常常80-90分的比较多,也许就要换一种算法,当然这是后话,和考试无关了.)</p>
<p>哈夫曼算法步骤如下:</p>
<ul>
<li>(1)根据给定的n个权值,构成一排结点T,每个的值都是相应的权值.</li>
<li>(2)从T中选两棵权值最小的二叉树,作为左右子树构成一棵新的二叉树T’,并且新二叉树的权值为左右子树权值之和.</li>
<li>(3)将新二叉树T’并入到T中,删除原来的两棵二叉树.</li>
<li>(4)重复2,3直到只剩一棵二叉树.这棵树就是哈夫曼树.</li>
</ul>
<p>哈夫曼树的带权路径长度WPL=∑wL 即所有叶子结点的 权值*比较次数(层次数-1) 之和. 而WPL也正好等于所有分支结点(不包括叶子结点)的值之和.</p>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>图中将每个对象用一个顶点表示，并常用一个序号来标识一个顶点。 其中弧表示单向关系，边表示双向关系，用离散数学中的术语来说，则分别表示为非对称关系和对称关系。 弧用<a, b="">表示（A为尾，B为头），边用(A, B)表示。</a,></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">一个图G由两部分内容构成，即顶点(vertex)集合(V)和边(或弧edge)的集合(E)，并用二元组(V, E)来表示，记做G = (V, E)</div></pre></td></tr></table></figure>
<ul>
<li>根据顶点间的关系是否有向而引入有向图和无向图。</li>
<li>给每条边或弧加上权值，这样的带权图称为网络。</li>
<li>若无向图中任意两点间都有一条边，则称此图G为无向完全图。(共有边数 n*(n-1)/2 )</li>
<li><p>若有向图中任意一个顶点到其余各点间均有一条弧，则称为有向完全图。(共有弧数 n*(n-1) ) 若一个图G1是从G中选取部分顶点和部分边（或弧）组成，则称G1是G的子图。（注意，顶点和边必须都为子关系）</p>
</li>
<li><p>若无向图中两个顶点i, j之间存在一条边，则称i, j相邻接，并互为邻接点。 在有向图中，若存在弧<vi, vj="">，也做Vi, Vj相邻接，但为区别弧的头、尾顶点，可进一步称做Vi邻接到Vj，Vj邻接于Vi。</vi,></p>
</li>
</ul>
<p>与一个顶点相邻接的顶点数称为该顶点的度。 在有向图中，进入一个顶点的弧数称为该顶点的入度，从一个顶点发出的弧数为该顶点的出度，并将入度和出度之和作为该顶点的度。</p>
<p>一个顶点经过一定的可经路程到达另一个顶点，就为顶点之间的路径。</p>
<ul>
<li>若某路径所经过的顶点不重复，则称此路径为简单路径。</li>
<li>若某路径的首尾相同，则称此路径为回路（或称为环）。</li>
<li><p>若某回路的中间不重复，则称之为简单回路。</p>
</li>
<li><p>若无向图中任意两点之间均存在路径，则称G为连通图，否则不连通，就存在若干个连通分量。</p>
</li>
<li><p>若有向图中任意两点间可以互相到达，则称为强连通图。</p>
</li>
</ul>
<p>一个无向图，连通并且无回路，称这样的图为树。 若有向图中仅有一个顶点的入度为0，其余顶点的入度都为1，称此图为有向树，入度为0的顶点为根。</p>
<h3 id="图的存储结构："><a href="#图的存储结构：" class="headerlink" title="图的存储结构："></a>图的存储结构：</h3><h5 id="1。邻接矩阵表示"><a href="#1。邻接矩阵表示" class="headerlink" title="1。邻接矩阵表示"></a>1。邻接矩阵表示</h5><p>对n个顶点的图来说，其邻接矩阵为n*n阶的。 邻接矩阵的元素存放边（弧）的权值，对不存在的边（弧），则用0或∞表示。 定义格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#define n 6    /* 图顶点数 */ </div><div class="line">#define e 8    /* 图的边（弧）数 */</div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">    vextype vexs[n];    /* 顶点类型 */</div><div class="line">    datatype arcs[n][n];    /* 权值类型 */</div><div class="line">&#125; graph;</div></pre></td></tr></table></figure>
<p>建立一个无向网络的算法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">CreateGraph(graph *G) </div><div class="line">&#123; </div><div class="line">    int i, j, k; </div><div class="line">    float w; </div><div class="line">    for (i=0; i&lt;n; i++) </div><div class="line">        G-&gt;vexs[i] = getchar();    /* 读入顶点信息，创建表，这里用字符型 */ </div><div class="line">    for (i=0; i&lt;n; i++) </div><div class="line">        for (j=0; j&lt;n; j++) </div><div class="line">            G-&gt;arcs[i][j] = 0;    /* 邻接矩阵初始化 */ </div><div class="line">    for (k=0; k&lt;e; k++) </div><div class="line">    &#123; </div><div class="line">        scanf(&quot;%d%d%f&quot;, &amp;i, &amp;j, &amp;w);    /* 读入边(vi, vj)上的权w(暂用float类型) */ </div><div class="line">        G-&gt;arcs[i][j] = w; </div><div class="line">        G-&gt;arcs[j][i] = w; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-邻接表表示法"><a href="#2-邻接表表示法" class="headerlink" title="2.邻接表表示法"></a>2.邻接表表示法</h5><p>将每个顶点的邻接点连成链表，并将各链表的表头指针合在一起（用数组或链表表示均可），其中每个头指针与该结点的信息合为一个整体结点。 如果将邻接表中各顶点的邻接表变为其前驱顶点即可，从而得到逆邻接表。 用邻接表存储网络时，需要将各条边（弧）的权值作为相应邻接结点中的一个字段。 结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">typedef struct node</div><div class="line">&#123;</div><div class="line">    int adjvex;    /* 邻接点域 */</div><div class="line">    struct node *next;    /* 链域 */</div><div class="line">    datatype arc;    /* 权值 */</div><div class="line">&#125; edgenode;    /* 边表指针 */</div><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">    vextype vertex;    /* 顶点信息 */</div><div class="line">    edgenode *link;    /* 边表头指针 */</div><div class="line">&#125; vexnode;    /* 顶点表结点 */</div><div class="line">vexnode gnode[n];    /* 整个图的构成 */</div><div class="line"> 建立无向图的邻接表：</div><div class="line">CreateAdjlist(gnode)</div><div class="line">&#123;</div><div class="line">    int i, j, k;</div><div class="line">    edgenode *s;</div><div class="line">    for (i=0; i&lt;n; i++)    /* 读入顶点信息 */</div><div class="line">    &#123;</div><div class="line">        gnode[i].vertex = getchar();</div><div class="line">        gnode[i].link = NULL;    /* 边表指针初始化 */</div><div class="line">    &#125;</div><div class="line">    for (k=0; k&lt;e; k++)    /* 建立边表 */</div><div class="line">    &#123;</div><div class="line">        scanf(&quot;%d%d&quot;, &amp;i, &amp;j);    /* 读入边(vi,vj)的顶点序号 */</div><div class="line">        s = malloc(sizeof(edgenode));    /* 生成邻接点序号为j的表结点 */</div><div class="line">        s-&gt;adjvex = j;</div><div class="line">        s-&gt;next = gnode[i].link;</div><div class="line">        gnode[i].link = s;    /* 将*s插入顶点vi的边表头部(插到头部比尾部简单) */</div><div class="line">        s = malloc(sizeof(edgenode));    /* 生成邻接点序号为i的边表结点*s */</div><div class="line">        s-&gt;adjvex = i;</div><div class="line">        s-&gt;next = gnode[j].link;</div><div class="line">        gnode[j].link = s;    /* 将*s插入顶点vj的边表头部(最后四行由于是无向图，所以相互，两次) */</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="图的遍历算法及其应用"><a href="#图的遍历算法及其应用" class="headerlink" title="图的遍历算法及其应用"></a>图的遍历算法及其应用</h3><h5 id="1-深度遍历"><a href="#1-深度遍历" class="headerlink" title="1.深度遍历"></a>1.深度遍历</h5><ul>
<li>(1)访问V0</li>
<li>(2)依次从V0 的各个未被访问的邻接点出发深度遍历 （两句话说的非常清楚。是一种以深度为绝对优先的访问。）</li>
</ul>
<h5 id="2。深度优先搜索遍历算法"><a href="#2。深度优先搜索遍历算法" class="headerlink" title="2。深度优先搜索遍历算法"></a>2。深度优先搜索遍历算法</h5><p>由于实际算法比较复杂，这里算法依赖两个函数来求解（对于不同的存储结构有不同的写法） firstadj(G, v)：返回图G中顶点v的第一个邻接点。若不存在，返回0。 nextadj(G, v, w)：返回图G中顶点v的邻接点中处于w之后的那个邻接点。若不存在，返回0。 depth first search:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void dfs(graph G, int v)</div><div class="line">&#123;</div><div class="line">    int w;</div><div class="line">    visit(v);</div><div class="line">    visited[v] = 1;</div><div class="line">    w = firstadj(G, v)</div><div class="line">    while (w != 0)</div><div class="line">    &#123;</div><div class="line">        if (visited[w] == 0)</div><div class="line">            dfs(w);</div><div class="line">        w = nextadj(G, v, w);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果不是连通图，或者是有向图，那么访问一个v不可能遍历所有顶点。所以，需要再选择未被访问的顶点作为起点再调用dfs.</p>
<p>所以，深度遍历图的算法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void dfs_travel(graph G)</div><div class="line">&#123;</div><div class="line">    int i;</div><div class="line">    for (i=1; i&lt;=n; i++)</div><div class="line">        visited[i] = 0;        //初始化各顶点的访问标志</div><div class="line">    for (i=1; i&lt;=n; i++)</div><div class="line">        if (visited[i] == 0)</div><div class="line">            dfs(G, i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-广度优先搜索遍历算法"><a href="#3-广度优先搜索遍历算法" class="headerlink" title="3.广度优先搜索遍历算法"></a>3.广度优先搜索遍历算法</h5><p>广度优先搜索遍历算法(bfs)是一种由近而远的层次遍历算法，从顶点V0出发的广度遍历bfs描述为：</p>
<ul>
<li>(1)访问V0（可作为访问的第一层）；</li>
<li>(2)假设最近一层的访问顶点依次为V1, V2, …, Vk，则依次访问他们的未被访问的邻接点。</li>
<li>(3)重复2，直到找不到未被访问的邻接点为止。</li>
</ul>
<p>算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">void bfs(graph G, int V0)</div><div class="line">&#123;</div><div class="line">    int w;</div><div class="line">    int v;</div><div class="line">    queue Q;</div><div class="line">    init_queue(Q);</div><div class="line">    visit(V0);</div><div class="line">    visited[V0] = 1;</div><div class="line">    Enqueue(Q, V0);</div><div class="line">    while (!empty(Q))</div><div class="line">    &#123;</div><div class="line">        v = Outqueue(Q);</div><div class="line">        w = firstadj(G, v);</div><div class="line">        while (w != 0)</div><div class="line">        &#123;</div><div class="line">            if (visited[w] == 0)</div><div class="line">            &#123;</div><div class="line">                visit(w);</div><div class="line">                visited[w] = 1;</div><div class="line">                Enqueue(Q, w);</div><div class="line">            &#125;</div><div class="line">            w = nextadj(G, v, w);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>广度遍历图的算法和深度一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void bfs_travel(graph G)</div><div class="line">&#123;</div><div class="line">    int i;</div><div class="line">    for (i=1; i&lt;=n; i++)</div><div class="line">        visited[i] = 0;</div><div class="line">    for (i=1; i&lt;=n; i++)</div><div class="line">        if (visited[i] = 0)</div><div class="line">            bfs(G, i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最小生成树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">从图中选取若干条边，将所有顶点连接起来，并且所选取的这些边的权值之和最小。</div></pre></td></tr></table></figure>
<p>这样所选取的边构成了一棵树，称这样的树为生成树，由于权值最小，称为最小生成树。</p>
<h3 id="构造最小生成树有两种方法："><a href="#构造最小生成树有两种方法：" class="headerlink" title="构造最小生成树有两种方法："></a>构造最小生成树有两种方法：</h3><h6 id="1-Prim算法："><a href="#1-Prim算法：" class="headerlink" title="1.Prim算法："></a>1.Prim算法：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">首先将所指定的起点作为已选顶点，然后反复在满足如下条件的边中选择一条最小边，直到所有顶点成为已选顶点为止（选择n-1条边）：一端已选，另一端未选。</div></pre></td></tr></table></figure>
<p>(简单的说，就是先任选一点，然后每次选择一条最小权值的边，而且只连接到一个已选顶点)</p>
<h6 id="2-Kruskal算法："><a href="#2-Kruskal算法：" class="headerlink" title="2.Kruskal算法："></a>2.Kruskal算法：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">反复在满足如下条件的边中选出一条最小的，和已选边不够成回路。</div><div class="line">(条件就是不够成回路就OK，反复选最小边，知道所有顶点都有连接）</div></pre></td></tr></table></figure>
<p>最短路径： 一般即是要一个顶点到其余各个顶点的最短路径。（比如隔很远的顶点，要绕哪几条边走） 求解方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">首先，我们要画一个表，每个顶点有path和dist两个值，分别用来存储到各点的最短路径（比如(1,5,6)，就是1-5-6这个路径）和相应的长度（到该点的权值之和）。</div></pre></td></tr></table></figure>
<ul>
<li>(1)对V以外的各顶点，若两点间的邻接路径存在，则将其作为最短路径和最短长度存到path[v]和dist[v]中。(实际上也就是最开始对顶点的直接后继进行处理）</li>
<li>(2)从未解顶点中选择一个dist值最小的顶点v，则当前的path[v]和dist[v]就是顶点v的最终解（从而使v成为已解顶点）。</li>
<li>(3)如果v的直接后继经过v会更近一些，则修改v的直接后继的path和dist值。</li>
</ul>
<p>(上面的确是很难懂，只能通过例子自己慢慢熟悉。）</p>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><blockquote>
<p>在软件设计中，通常是将待查找的数据元素集以某种表的形式给出，从而构成一种新的数据结构－－查找表。 表包括一些“元素”，“字段”等等概念。</p>
</blockquote>
<p>在一个数据表中，若某字段的值可以标识一个数据元素，则称之为关键字（或键）。 若此关键字的每个值均可以唯一标识一个元素，则称之为主关键字，否则，若该关键字可以标识若干个元素，则称之为次关键字。</p>
<p>查找算法的时间性能一般以查找次数来衡量。所谓查找长度是指查找一个元素所进行的关键字的比较次数。常以平均查找次数、最大查找次数来衡量查找算法的性能。</p>
<h5 id="一、简单顺序查找"><a href="#一、简单顺序查找" class="headerlink" title="一、简单顺序查找"></a>一、简单顺序查找</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int seq_seach(elementtype A[], int n, keytype x)</div><div class="line">&#123;</div><div class="line">    int i;</div><div class="line">    A[0].key = x;        //设定监视哨</div><div class="line">    for (i=n; A[i].key!=x; i--);</div><div class="line">    return i;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>监视哨是一个小技巧，查找失败时，这里设定的数据是A[1]-A[n]，肯定可以在A[0]中找到该元素，并返回0表示查找失败。如果不设定监视哨，则在每次循环中要判断下标是否越界：for (i=1; i!=n&amp;&amp;A[i].key!=x;i–); 可以节省一半的时间。</p>
<h5 id="二、有序表的二分查找"><a href="#二、有序表的二分查找" class="headerlink" title="二、有序表的二分查找"></a>二、有序表的二分查找</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">int bin_search(elementtype A[], int n, keytype x)</div><div class="line">&#123;</div><div class="line">    int mid, low, high;</div><div class="line">    low = 0;</div><div class="line">    high = n - 1;</div><div class="line">    while (low &lt;= high)</div><div class="line">    &#123;</div><div class="line">        mid = (low + high) / 2;</div><div class="line">        if (x == A[mid].key)</div><div class="line">            return mid;</div><div class="line">        else if (x &lt; A[mid].key)</div><div class="line">            high = mid - 1;</div><div class="line">        else</div><div class="line">            low = mid + 1;</div><div class="line">    &#125;</div><div class="line">    return -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也可以使用递归算法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">int bin_search(elementtype A[], int low, int high, keytype x)</div><div class="line">&#123;</div><div class="line">    int mid;</div><div class="line">    if (low &lt; high)</div><div class="line">        return -1;</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        mid = (low + high) / 2;</div><div class="line">        if (x == A[mid].key)</div><div class="line">            return mid;</div><div class="line">        else if (x &lt; A[mid],key)</div><div class="line">            return bin_search(A, low, mid - 1, x);</div><div class="line">        else</div><div class="line">            return bin_search(A, mid - 1, high, x);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><ul>
<li>增排序和减排序：如果排序的结果是按关键字从小到大的次序排列的，就是增排序，否则就是减排序。</li>
<li>内部排序和外部排序：如果在排序过程中，数据表中所有数据均在内存中进行，则这类排序为内部排序，否则就是外部排序。</li>
<li>稳定排序和不稳定排序：在排序过程中，如果关键字相同的两个元素的相对次序不变，则称为稳定排序，否则是不稳定排序。</li>
</ul>
<p>在分析算法的时间性能时，主要以算法中用的最多的基本操作的执行次数（或者其数量级）来衡量，这些操作主要是比较、移动和交换元素。有时，可能要用这些次数的平均数来表示。</p>
<h3 id="一、插入排序"><a href="#一、插入排序" class="headerlink" title="一、插入排序"></a>一、插入排序</h3><p>基本思想：</p>
<blockquote>
<p>把整个待排序子表看作是左右两部分，其中左边为有序区，右边为无序区，整个排序过程就是把右边无序区中的元素逐个插入到左边的有序区中，以构成新的有序区。 实际中，开始排序时把第一个元素A[0]（或A[1]）看作左边的有序区，然后把剩下的2～N个元素依次插入到有序表中。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">void insert_sort(elementtype A[n+1])</div><div class="line">&#123;</div><div class="line">    int i;</div><div class="line">    for (i=2; i&lt;=n; i++)</div><div class="line">    &#123;</div><div class="line">        A[0] = A[i];        //设置监视哨，这个数组同样是从1开始，A[0]就设为监视哨</div><div class="line">        j = i - 1;</div><div class="line">        while (A[j].key &gt; A[0].key)</div><div class="line">        &#123;</div><div class="line">            A[j + 1] = A[j];</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">        A[j + 1] = A[0];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>明白这种方法的简单原理： a1 a2 a3 … a(i-1) ai … 先将ai临时保存起来，然后把a(i-1)向前只要是比ai大的向后移，再把ai填进去即可。</p>
<h3 id="二、快速排序"><a href="#二、快速排序" class="headerlink" title="二、快速排序"></a>二、快速排序</h3><p>速度最快的办法！一定要掌握，考试重点。</p>
<p>基本思想：</p>
<blockquote>
<p>首先，选定一个元素作为中间元素，然后将表中所有元素与该中间元素相比较，将表中比中间元素小的元素调到表的前面，将比中间元素大的元素调到后面，再将中间数放在这两部分之间作为分界点，这样便得到一个划分；然后再对左右两部分分别进行快速排序，如此反复，直到每个子表仅有一个元素或空表为止。 中间数一般选择部分的第一个元素。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">int partition(elementtype A[n], int s, int t)    //s,t是要排序元素的起点和终点,并返回最后中间元素位置</div><div class="line">&#123;</div><div class="line">    elementtype x = A[s];    //保存中间元素到临时变量x,以腾出空位</div><div class="line">    int i = s;                        //置两端搜索位置的初值</div><div class="line">    int j = t;</div><div class="line">    while (i != j)        //两端位置重和再停止</div><div class="line">    &#123;</div><div class="line">        while (i &lt; j &amp;&amp; A[j].key &gt; x.key) j--;    //从后面搜索“小”的元素</div><div class="line">        if (i &lt; j)        //如果找到，就调到前面的空位中</div><div class="line">        &#123;</div><div class="line">            A[i] = A[j];</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        while (i &lt; j &amp;&amp; A[i].key &lt; x.key) i++;    //从前面搜索“大”的元素</div><div class="line">        if (i &lt; j)        //如果找到，调到后面的空位中</div><div class="line">        &#123;</div><div class="line">            A[j] = A[i];</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    A[i] = x;        //将中间数移到最终位置上</div><div class="line">    return i;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整个算法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void quick_sort(elementtype A[n], int s, int t)    //对数组中下标从s到t的部分进行快速排序，如果是整个表就是0, n-1</div><div class="line">&#123;</div><div class="line">    int i;</div><div class="line">    if (s &lt; t)    //表中至少有两个元素时</div><div class="line">    &#123;</div><div class="line">        i = partition(A, s, t);    //划分排序一次</div><div class="line">        quick_sort(A, i + 1, t);    //对后面部分快速排序</div><div class="line">        quick_sort(A, s, i - 1);    //对前面部分快速排序</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="三、选择排序："><a href="#三、选择排序：" class="headerlink" title="三、选择排序："></a>三、选择排序：</h3><p>在待排序子表中完整地比较一遍以确定最大（小）元素，并将该元素放在子表的最前（后）面。 【注：可能发觉和冒泡法比较类似，但注意选择法是全部比较一遍，找到最小元素的下标，再进行一次交换，而冒泡则是进行多次交换】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">void select_sort(elementtype A[n])</div><div class="line">&#123;</div><div class="line">   int min, i, j;</div><div class="line">   elementtype temp;</div><div class="line">   for (i=0; i&lt;n-1; i++)</div><div class="line">   &#123;</div><div class="line">      min = i;</div><div class="line">      for (j=i+1; j&lt;n; j++)</div><div class="line">         if (A[min].key &gt; A[j].key) min = j;</div><div class="line">      if (min != i)</div><div class="line">      &#123;</div><div class="line">         temp = A[i];</div><div class="line">         A[i] = A[min];</div><div class="line">         A[min] = temp;</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="四、归并排序"><a href="#四、归并排序" class="headerlink" title="四、归并排序"></a>四、归并排序</h3><p>所谓归并是指将两个或两个以上的有序表合并成一个新的有序表。 归并算法：</p>
<p>假设两个序列A[m]和B[n]为非降序列（即存在相同元素的升序列），现要把他们合并为一个非降序列C[m+n]。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void merge(elementtype A[], elementtype B[], elementtype C[], int m, int n)</div><div class="line">&#123;</div><div class="line">    int ia = 0, ib = 0, ic = 0;</div><div class="line">    while (ia &lt; m &amp;&amp; ib &lt; n)</div><div class="line">        if (A[ia] &lt;= B[ib])</div><div class="line">            C[ic++] = A[ia++];</div><div class="line">        else</div><div class="line">            C[ic++] = B[ib++];</div><div class="line">    while (ia &lt; m)</div><div class="line">        C[ic++] = A[ia++];</div><div class="line">    while (ib &lt; n)</div><div class="line">        C[ic++] = B[ib++];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数据结构与算法/" rel="tag"># 数据结构与算法</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/03/10/关于layoutSubviews和drawRect/" rel="next" title="关于layoutSubviews和drawRect">
                <i class="fa fa-chevron-left"></i> 关于layoutSubviews和drawRect
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/06/20/性能优化小结/" rel="prev" title="性能优化小结">
                性能优化小结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/05/21/数据结构常见操作与总结/"
           data-title="数据结构常见操作与总结" data-url="http://dupengfei.com/2016/05/21/数据结构常见操作与总结/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="杜鹏飞" />
          <p class="site-author-name" itemprop="name">杜鹏飞</p>
           
              <p class="site-description motion-element" itemprop="description">iOS Developer</p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/dupengfei" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://plus.google.com/u/0/117309292640302365524" target="_blank" title="G+">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  G+
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一、栈"><span class="nav-number">1.</span> <span class="nav-text">一、栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-顺序栈"><span class="nav-number">1.0.1.</span> <span class="nav-text">1.顺序栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-链栈"><span class="nav-number">1.0.2.</span> <span class="nav-text">2.链栈</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、队列"><span class="nav-number">2.</span> <span class="nav-text">二、队列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-顺序队列"><span class="nav-number">3.</span> <span class="nav-text">1.顺序队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-链队列"><span class="nav-number">3.0.1.</span> <span class="nav-text">2.链队列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数组"><span class="nav-number">4.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#树"><span class="nav-number">5.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、树"><span class="nav-number">5.0.1.</span> <span class="nav-text">一、树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树"><span class="nav-number">5.0.2.</span> <span class="nav-text">二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树的遍历："><span class="nav-number">5.0.3.</span> <span class="nav-text">二叉树的遍历：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线索二叉树"><span class="nav-number">5.0.4.</span> <span class="nav-text">线索二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#树和森林"><span class="nav-number">5.0.5.</span> <span class="nav-text">树和森林</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-树的存储结构："><span class="nav-number">5.0.5.0.1.</span> <span class="nav-text">1.树的存储结构：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-树（森林）与二叉树的转换"><span class="nav-number">5.0.5.0.2.</span> <span class="nav-text">2.树（森林）与二叉树的转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-树（森林）的遍历"><span class="nav-number">5.0.5.0.3.</span> <span class="nav-text">3.树（森林）的遍历</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哈夫曼树"><span class="nav-number">5.0.6.</span> <span class="nav-text">哈夫曼树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#图"><span class="nav-number">6.</span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#图的存储结构："><span class="nav-number">6.0.1.</span> <span class="nav-text">图的存储结构：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1。邻接矩阵表示"><span class="nav-number">6.0.1.0.1.</span> <span class="nav-text">1。邻接矩阵表示</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-邻接表表示法"><span class="nav-number">6.0.1.0.2.</span> <span class="nav-text">2.邻接表表示法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图的遍历算法及其应用"><span class="nav-number">6.0.2.</span> <span class="nav-text">图的遍历算法及其应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-深度遍历"><span class="nav-number">6.0.2.0.1.</span> <span class="nav-text">1.深度遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2。深度优先搜索遍历算法"><span class="nav-number">6.0.2.0.2.</span> <span class="nav-text">2。深度优先搜索遍历算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-广度优先搜索遍历算法"><span class="nav-number">6.0.2.0.3.</span> <span class="nav-text">3.广度优先搜索遍历算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造最小生成树有两种方法："><span class="nav-number">6.0.3.</span> <span class="nav-text">构造最小生成树有两种方法：</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-Prim算法："><span class="nav-number">6.0.3.0.0.1.</span> <span class="nav-text">1.Prim算法：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-Kruskal算法："><span class="nav-number">6.0.3.0.0.2.</span> <span class="nav-text">2.Kruskal算法：</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#查找"><span class="nav-number">7.</span> <span class="nav-text">查找</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#一、简单顺序查找"><span class="nav-number">7.0.0.0.1.</span> <span class="nav-text">一、简单顺序查找</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二、有序表的二分查找"><span class="nav-number">7.0.0.0.2.</span> <span class="nav-text">二、有序表的二分查找</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#排序"><span class="nav-number">8.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、插入排序"><span class="nav-number">8.0.1.</span> <span class="nav-text">一、插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、快速排序"><span class="nav-number">8.0.2.</span> <span class="nav-text">二、快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、选择排序："><span class="nav-number">8.0.3.</span> <span class="nav-text">三、选择排序：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四、归并排序"><span class="nav-number">8.0.4.</span> <span class="nav-text">四、归并排序</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">杜鹏飞</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"dupengfei"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  

  

  

  

  


  

</body>
</html>
